---
title: 垃圾收集器与内存分配策略
date: 2023/4/18 
categories: JVM
tags: jvm
comments: true
photo: https://img2.baidu.com/it/u=1734247813,400897296&fm=253&fmt=auto&app=138&f=PNG?w=1111&h=500
---

垃圾收集器在对堆进行回收前，需要先识别出垃圾

<!--more-->

### JVM如何识别垃圾

#### 引用计数算法

**算法思路**：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计算器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

**优点**：实现简单，判定效率高

**缺点**：难以解决对象之间相互循环引用的问题

> 对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。

#### 可达性分析算法

**算法思路**：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

![image-20230418223424315](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230418223424315.png)

在Java中，可作为GC Roots的对象包括以下几种：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI（即一般说的Native方法）引用的对象

### 引用

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。

在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用

JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱

1. **强引用**：我们平时 new 了一个对象就强引用，例如 Object obj = new Object();即 使在内存不足✁情况下，JVM 宁愿抛出 OutOfMemory 错误也不会回收这种 对象
2. **软引用**：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如 果内存空间不足了，就会回收这些对象内存。
3. **弱引用**：具有弱引用对象拥有更短暂生命周期。在垃圾回收器线程扫描它所管辖 内存区域过程中，一旦发现了只具有弱引用对象，不管当前内存空间足够 与否，都会回收它内存。
4. **虚引用**：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可 能被垃圾回收器回收。**虚引用主要用来跟踪对象被垃圾回收器回收活动**

### 回收方法区

永久代的垃圾收集主要回收两部分内容：**废弃常量和无用的类**。

类需要满足以下3个条件才能算是“无用的类”：

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

### 垃圾收集算法

#### 标记-清除算法

**算法思想**：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象

![image-20230418224837776](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230418224837776.png)

**缺点**：

- 效率问题，标记和清除两个过程的效率都不高
- 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

#### 复制算法

**算法思想**：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

![image-20230418225054360](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230418225054360.png)

**缺点**：内存缩小为了原来的一半

#### 标记-整理算法

**算法思想**：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![image-20230418225302067](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230418225302067.png)

#### 分代收集算法

![image-20230418225706958](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230418225706958.png)

- 在 Java 中，堆被划分成两个不同的区域：**新生代 ( Young )、老年代 ( Old )**。而**新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor**。这样划分的目的是为了使 JVM 能够 更好的管理堆内存中的对象，包括内存的分配以及回收。
- **新生代**中一般保存新出现的对象，所以每次垃圾收集时都发现大批对象死去，只有少量对象存活， 便采用了 **复制算法** ，只需要付出少量存活对象的复制成本就可以完成收集。
- **老年代**中一般保存存活了很久的对象，他们存活率高、没有额外空间对它进行分配担保，就必须采 用 **“标记-清理”或者“标记-整理”** 算法。
- 永久代就是JVM的方法区。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。 这个区中的东西比老年代和新生代更不容易回收

### 垃圾回收器

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了 7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆 的G1收集器。不同收集器之间的连线表示它们可以搭配使用。

![image-20230418230028706](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230418230028706.png)

| 垃圾回收器        | 工作 区域       | 回收算法               | 工 作 线 程 | 用户 线程 并行 | 描述                                                         |
| ----------------- | --------------- | ---------------------- | ----------- | -------------- | ------------------------------------------------------------ |
| Serial            | 新生代          | 复制算法               | 单线程      | 否             | Client模式下默认新生代收集器。 简单高效                      |
| ParNew            | 新生代          | 复制算法               | 多 线 程    | 否             | Serial的多线程版本，Server模式 下首选， 可搭配CMS的新生代收集 器 |
| Parallel Scavenge | 新生代          | 复制算法               | 多 线 程    | 否             | 目标是达到可控制的吞吐量                                     |
| Serial Old        | 老年代          | 标记-整 理             | 单 线 程    | 否             | Serial老年代版本，给Client模式下 的虚拟机使用                |
| Parallel Old      | 老年代          | 标记-整 理             | 多 线 程    | 否             | Parallel Scavenge老年代版本，吞 吐量优先                     |
| G1                | 新生代 + 老年代 | 标记-整 理 + 复 制算法 | 多 线 程    | 是             | JDK1.9默认垃圾收集器                                         |
|                   |                 |                        |             |                |                                                              |

### 内存分配与回收策略

![image-20230418225706958](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230418225706958.png)

1、**对象优先在新生代Eden区中分配**。当Eden区没有足够空间进行分配时，虚拟机将发起一次minor gc

2、当 Eden 区空间满了， Java 虚拟机会触发一次 minor gc，以收集新生代 垃圾，存活下来对象，则会转移到 survivor 区

3、**大对象**（需要大量连续内存空间Java 对象，如那种很长字符串）直接进入老年代

4、如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1，每熬过一次 Minor GC，年龄+1，若**年龄超过一定限制 （15）**，则被晋升到老年态。即**长期存活的对象进入老年态**。

5、老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC， **FullGC 清理整个内存堆** – 包括年轻代和年老代

6、Major GC 发生在老年代 GC，清理老年区，经常会伴随至少一次 Minor GC， 比 Minor GC 慢 10 倍以上

> 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
>
> 老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

